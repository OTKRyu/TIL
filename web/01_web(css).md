# css

cascading style sheets의 약자

html의 기본 스타일링 능력으로는 한계가 있기 때문에, 추가적으로 스타일을 입혀서 만들기 위해서 사용한다.

html이 뼈대라면 css는 살집을 붙이는 과정이다. 고로 html없이 css를 만들 수는 없다.

축약어로 빠르게 설정하는 방법이 있다.

대부분의 css에 작성하는 내용은 html의 `<style>` 태그에 들어가야할 내용을 적는 것으로 `<style>` 태그는 대체로 `<head>`에 쓰는 편이다.

ex) div.classname>div.childname+div.sibling*3

## css 정의 방법
```
h1 {
	color: blue; # 세미콜론이 항상 붙는다.
	font_size: 15px;
} # dict의 key, value 적듯이 적고 쉼표 대신 세미콜론을 적는다고 생각하면 된다.
```
공통으로 사용될 속성은 외부참조를 사용하고, 따로 사용될 속성을 내부참조로 하거나, 혹은 단 하나의 개체에만 사용할 속성은 inline으로 쓰는 등 활용방법이 다양하다.
1. inline 방법
말 그대로 태그를 지정하고 inline으로 속성을 바로 적어주는 방법
2. 내부참조
헤드에 스타일이라는 태그에 접근해 속성을 적어주는 방법
3. 외부참조
`<head>`내 `<link>` 태그를 통해 참조경로를 적고 속성을 가져온다.

### selector
- html 문서에 특정요소를 선택하는 선택자, 이를 선택해야 이것만 꾸밀 수 있다.

- 기본 선택자(class는 동시에 여러개를 한 요소에 줄 수 있으며 띄어쓰기로 구분)
  - 전체 선택자 : `*`로 접근 문서 내 모든 글자를 대상으로 적용
  - 태그(요소) 선택자: 태그의 이름을 통해 접근, 해당 요소에만 적용, 여러 개를 동시에 할 수도 있다.

  옆으로 써도 되고 아래로 써도 된다. 다만 아래로 쓰는 것을 권장한다.

  - 클래스 선택자 :  class를 설정했을 경우, 해당 클래스에만 적용
    
    - 이 때 `.classname`으로 접근
    
  - 아이디 선택자 :  id를 설정했을 경우, 해당 id에만 적용
    - 이 때 `#idname`으로 접근
    - 아이디나 클래스나 똑같은 방식으로 사용하지만, id는 문서당 한번만 사용가능하고 요소에도 단일id만 쓸 수 있다.
    - 그렇기 때문에 다른 객체에 같은 id를 할당하면 자동으로 포커싱을 이동해주는 등의 기능을 사용할수 있다.
    
    ```html
    <!--example-->
    <form>
        <label for="id"></label>
        <input type="text" id="id"></input>
    </form>
    ```
    
  - 속성 선택자 : 태그의 속성을 조회하여 일치할 경우에만 적용하도록 만드는 선택자. 
  
    - 선택자이름[속성이름] or 선택자이름[속성이름="지정한이름"] 식으로 사용한다.
  
- 결합자(combinarors) : html을 쓸 때 설정했던 자식관계를 묶어서 설정하고 싶을 때 사용
  
  - 자식 결합자 :  클래스의 이름을 기준으로 한 단계 아래 있는 자식을 지정할 때 사용
    - 이 때 `.classname > elementname`로 접근
  - 자손 결합자 : 클래스의 이름을 기준으로 아래 있는 자식 전부를 지정할 때 사용
    - 이 때 `.classname elementname`으로 접근
  - 일반 형제, 인접 형제 결합자

### 적용 우선 순위

- 중요도

  - !important : 우선순위 최우선으로 올리는 명령어로 강제로 이 속성을 가장 먼저 사용하기 때문에 디버깅할 때 위험하다. 상속의 경우 다르게 작동하여 안 먹을 수 있다.

  어지간하면 쓰지 않는다.

- 우선 순위 : 이 때 인라인이나 id, 요소 선택자들을 사용하면 이 우선순위를 생각하는 일이 많아져서 불편해 진다.

따라서 편하게 쓰기 위해 될 수 있는한 class선택자만을 써서 코드를 짜려고 하는 편이다.

- 추가로 내부 참조와 외부 참조의 우선순위는 동등하며, 코드의 순서로 판단한다.
  1. inline 선택자
  2. id 선택자
  3. class 선택자
  4. 요소 선택자
- 그 다음 코드 순서로 판단한다. 소스 코드상 아래쪽에 있을수록 우선순위를 가진다.

### css 상속
파이썬과 같이 부모의 것을 자식에게 상속, 다만 전부 상속하는 것은 아님
- 상속되는 것
  - text관련
  - opacity(투명도)
  - visibility(볼 수 있는지 없는지)
- 상속되지 않는 것
  - box model 관련 요소(`width`, `height`, `margin`, `padding`, `border` 등등)

## css 속성

속성을 쓸 때, 그 안에 텍스트에 적용되는 것과, 개체에 적용되는 것이 따로 있다. 이를 분리해서 생각하는 습관이 필요하다.

- `font-size` : 글자 크기

- `font-family` : 글자체

- `width` : 두께, 이것과 마진을 조정할 경우가 많은데,

  마진을 조정할 때 이 두께속성이 있어야 이를 기준으로 마진을 auto로 조정할 수 있다.

- `color` : 글자색

- `hilight` : 강조

- `line-height` : 글자가 있는 높이를 결정, 기본적으로 최상단에 위치(행간)

- `font-weight` 등등

### css 단위

#### 크기
- `px` : 픽셀
- `%` : 부모의 크기 속성을 받아와 그걸 기준으로 %로 환산해준다.
- `em` 
  - 상속을 받을 때마다 곱연산이 일어날 가능성이 있으므로 권장하지 않는다.
  - 배수 단위, 요소에 지정된 사이즈의 상대적인 사이즈
- `rem`
  - 최상위 요소의 사이즈를 기준으로 만든 상대 사이즈
  - 기본값에 단 한번만 연산을 하는 기준이므로 조절하기 쉬워서 권장한다.
- viewport 기준 단위(사용자시점에서의 배율)
  - vw, vh, vmin, vmax 등이 있다.

#### 색상
1. 색상 키워드
2. `rgb` 색상
   - (256,256,256) 으로 작성 
3. `hsl` 색상
  - 색상, 채도, 명도

## 문서 표현

직접 만들 때 브라우저가 기본값으로 제공하는 것들이 문제가 될 수 있다. 이럴 때는 reset css라는 코드를 찾아서 적용해주면 되지만, 이 경우 모든 기본스타일이 날아가므로 이를 알고 해야한다.

- box model
  1. `margin` : 테두리 밖의 여백
     - top, botton, right, left 네 곳으로 구성
       - 하나만 입력시 4곳 모두 동일하게 입력
       - 두개 입력시 상하, 좌우로 입력
       - 세개 입력시 상, 좌우, 하로 입력
       - 네개 입력시 상 우 하 좌, 즉 시계방향순으로 값을 배정
     - `auto`라는 값을 써주면 중앙 정렬이 된다.
  2. `border` : 테두리, 축약으로 width style color를 한번에 쓸 수 있다.
     - `width` : 테두리의 너비를 말하는 것으로, 대체로 우리가 생각하는 너비가 이 값이기 때문에 이를 조정해야하는 경우가 많다.
     - `style`
     - `color ` : 색깔 지정
     - `text-align` : 박스 안의 텍스트의 위치를 지정
     - `margin`과 같이 축약어로 한번에 다 쓸 수 있음
  3. `padding` : 테두리와 컨텐츠사이의 여백
     - top, botton, right, left 네 곳으로 구성
     - margin과 같은 방식으로 입력 가능
  4. `content` : 실제 내용, 기본적으로 모든 기본 요소는 컨텐츠 기준이다.
   - `width` : 컨텐츠 기준의 너비이며, 기본값이다.
  
- 기본값을 변경해 사이즈를 조정하고 싶은 경우
  
  - `box-sizing : border-box`같이 변경해서 이를 조정할 수 있다.
  
- margin collapsing : 말 그대로 마진이 개체간에 충돌할 경우 둘 중 큰 값 하나에 맞춰져버리는 현상이다.
  
    블록레벨의 탑 바텀이 부딪힐 때만 일어나는 일로 이 때만 조정하면 된다.

이 순서대로 박스를 밖에서 안으로 채워나간다.

- display
  - `display : block`
    - 줄 바꿈, 화면 크기 전체의 가로 폭, 인라인 요소 들어갈 수 있다.
  - `display : inline`
    - 줄 바꿈 x, content 너비만큼, box가 아니기 때문에 box model 요소 활용 불가
  - `display: inline-block`
    - 두 개의 특성을 모두 가짐, 인라인처럼 한줄에 표시가능하면서 box model 요소 활용 가능
  - `display : none`
    - 해당 요소를 화면에 표시x(공간도 안 남음)
    - `visibility: hidden`은 공간은 남으나 화면에 표시는 안함.
  - 정렬
    - `margin`값을 `auto`로 조정해 `content`블록을 어느 쪽에 붙일지 사용
    - `text-align`을 이용해 글자가 어느쪽으로 붙을지 결정

- postion
  문서상에서 요소를 어디에 둘 것 인지를 결정, 기본값은 static
  추가로 `top`,`bottom`,`left`,`right`를 이용하여 이동하는 것도 가능하다.
  
  이 아래의 기준으로 움직인다의 기준은 개체의 좌상단을 기준으로 움직인다는 것을 의미한다.
  
  - `static` : 기본적인 배치 순서를 따른다. position을 줘봐야 의미가 없다. 움직이지 않는다.
  
  - `relative` : `static`으로 배치했을 때를 기준으로 이동을 준만큼 움직인다.
  
    이렇게 움직일 때 `static`이라면 차지했을 자리를 그대로 차지한 채로 움직이기 때문에, `static`들의 순서가 어그러지지 않는다.
  
    추가로 움직이지 않았을 경우 위치는 `relative`나 `static`이나 똑같다.
  
  - `absolute ` :  움직일 때 기준이 되는 자기 자리를 비워주고 움직이기 때문에 `static`들의 순서가 어그러진다.
  
    - 부모요소가 없을 경우, 바디 기준으로 움직인다. 
    - 부모요소가 있더라도 부모요소들 중 static이 아닌 것이 없으면, 그냥 보디 기준으로 움직인다.
    - 부모요소가 static이 아니라면, 그제서야 부모요소를 기준으로 움직인다.
    - 이 때 가장 인접한 부모요소(static이 아닌)를 기준으로 삼는다.
  
  - `fixed` : 스크롤이 움직이더라도 그 자리에 그대로 있는 것을 만들 때 사용, 자기 자리를 비워주면서 이동한다.
  
    - 화면 비율(%)에 맞춰서 쓰는것이 좋다
    
  - `sticky` : 화면 내부에 있을 때는 일반 포지션처럼 움직이지만, 요소가 화면 밖으로 밀려날 때가 되면 fixed처럼 화면에 붙어서 계속 따라오는 속성이다

## extra
### 미디어 쿼리

`@media`로 시작하는 쿼리로 구조가 함수와 비슷하다

```html
@media print {
  body {
    color: red;
  }
}
```

타입이 여러가지로 알맞은 유형을 찾아서 해야한다. 이 때 타입은 어떤 화면에서 볼 때를 정해주는 것이다.

- screen : 사용자가 보고 있는 화면을 의미하는 타입, 후에 추가적인 조건과 함께 쓰인다.
- print : 출력시의 화면을 나타낼 때 쓰는 타입

방향성(orientation)같은 값도 줄 수 있는데 가로와 세로 중 어느쪽이 긴지를 가지고 판단한다.

이러한 값들이 하나씩만 쓰이는 것이 아닌, 논리곱(and)이나 논리합(,)같은 연산을 통해 더 복잡한 조건으로 작동을 제어할 수 있다.

사용이 능숙해지면 부트스트랩처럼 정해져있는 것보다 더 자유롭게 사용할 수 있겠지만서도, 권장하지도 않고 그럴 필요성도 적은 편이다.

### 애니메이션

`@keyframes`로 시작하는 기능으로 html문서상에 움직이는 개체를 만들 수 있다.

%단위로 움직임을 제어하는 편이며 만든 animation이라는 css속성을 적용하고 상세설정을 마저 설정해주면 만들 수 있다. 

0~100 두 단위만 만들거면 from to로 제어하기도 한다.

자세한 만드는 법은 mdn문서 참조

추가로 animate.css라는 사이트에 정리해놓은 것이 있다.

### 폰트

부트스트랩 쓰듯이 폰트도 다운로드 받아서 링크를 걸어서 사용하면 된다.

무료로 제공되는 것들 중에는 구글 폰트가 있다.

### 아이콘

`<i>`태그에 클래스를 줘서 만드는 편이며, 글자기반으로 만든것이기 때문에 글자에 적용하는 속성들을 적용하여 변화를 줄 수 있다.

직접 만드는 것도 가능은 하지만, 만들어져 있는 것을 가져와 사용하는 것을 추천한다.

font-awesonme같은 사이트에서는 무료기능으로도 꽤나 많은 아이콘을 제공한다. 

