# algorithm

## queue

- 선입선출구조
- 맨 첫번째 원소가 저장된 위치를 `front`, 마지막 원소가 저장된 위치를 `rear`
- 주요연산
  - `enQueue(item)` : rear다음에 원소를 삽입
  - `deQueueu()` : front에서 원소를 삭제하고 반환하는 연산
  - `createQueue()` : 공백 상태의 큐를 생성하는 연산
  - `isEmpty()` : 큐가 공백상태인지 확인
  - `isFull()` : 큐가 포화상태인지 확인
  - `Qpeek()` : front의 위치하는 원소가 뭔지 확인하는 연산
- 선형큐
  - 1차원 배열을 이용한 큐
    - 큐의 크기  배열의 크기
    - `front` : 마지막에 꺼내질 원소의 인덱스
    - `rear` : 저장된 마지막 원소의 인덱스
  - 상태 표현
    - 초기 :  `front` = `rear` = -1
    - 공백 상태 :  `front` = `rear`
    - 포화 상태 :  `rear` = n-1(n:배열의 크기, n-1:배열의 마지막 인덱스)
  - 이용시의 문제점
    - 잘못된 포화상태 인식 : 실제 배열에는 빈 공간이 있으나 front와 rear가 모두 포화상태까지 진행되어버릴경우가 있다.
      - 해결방법1 : 매 원소가 꺼내질 때마다 모든 원소를 한칸씩 앞으로 이동시켜 front값이 항상 같은 값이 되도록 유지, 다만 이 경우 queue의 효율이 급격히 떨어진다
      - 해결방법2 : 원형으로 시작과 끝이 이어진 큐를 만든다.
- 원형큐
  - 초기 공백 상태 : `front` = `rear` = 0
  - index의 순환을 위해 mod를 이용.
  - 공백상태와 포화상태의 구분을 쉽게 하기 위해 `frnot`는 항상 비워둠(원형큐의 경우 포화상태일때도 front와 rear가 같아질 수 있기 때문)
  - 선형큐와 구동 과정이 거의 같지만 mod를 통해 순환한다는 것과 포화상태에 대한 판단방법정도만 다르다.
  - 포화상태일때는 `rear` + 1 = `front`일 때이다.
- 연결 큐 : 단순 연결 리스트를 이용한 큐
  -  큐의 원소: 단순 연결 리스트의 노드
  - 원소 순서: 노드의 연결 순서
  - `front` : 첫 번째 노드를 가르키는 링크
  - `rear` : 마지막 노드를 가르키는 링크
  - 초기 및 공백 상태 : `front` = `rear` = `None`

### Queue의 활용

- 버퍼
  - 데이터를 이동시키는 동안 잠시 데이터를 보관하는 메모리의 영역
  - 입출력 및 네트워크와 관련 기능에서 이용 순서대로 이루어져야하므로 큐가 사용된다.

## 우선순위 큐(Priority Queue)

우선순위를 가진 항목들을 저장하는 큐

선입선출이 아닌 우선순위대로 나가게 된다.

- 배열을 이용하여 우선순위 큐 구현
  - 삽입시 우선순위를 비교하여 적절한 위치에 삽입
  - 최고 우선순의 원소가 가장 앞에 위치
  - 문제점 : 배열을 사용하므로 삽입이나 삭제 연산이 일어날 때 원소의 재배치 발생, 이로 인하여 시간과 메모리 낭비가 큼, 이를 해결하기 위해 힙이나, 연결 리스트등을 이용하게 됨.





