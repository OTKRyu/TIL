# algorithm

## array 2

### 2차원 배열의 선언

- 배열들을 모아놓은 배열
- 차원에 따라 2개의 인덱스를 사용
- 파이썬에서는 별도의 작업없이도 그저 값을 대응시키는 것으로 사용 가능
- 입력 받는 방법 3가지
  - 각자 변수명을 정해서 따로따로 받아서 리스트에 넣기
  - 리스트를 미리 만들어놓고 반복문으로 한 리스트씩 리스트안에 넣기
  - list comprehension으로 작성

#### 배열의 순회

- 행 우선 순회
- 열 우선 순회
- 지그재그 순회
  - 행 우선 조회이나 한번은 정방향 한번은 역방향으로 조회하는 것을 말함

```python 
arr # 2차원 배열
n, m # 행, 열의 길이
for i in range(len(arr)):
    for j in range(len(arr[i])):
        arr[i][j+(m-1-2*j*(i%2))]
#another answer
for i in range(len(arr)):
    if i % 2 == 0:
        for j in range(len(arr[i])):
            arr[i][j]
    else:
        for j in range(len(arr[i])-1, -1, -1):
            arr[i][j]
```

- 델타를 이용한 2차 배열 탐색
  - 단위 이동에 해당하는 연산을 정의해놓은 뒤 이를 이용해 순회하는 방법

```python
dr = [ -1, 1, 0, 0]
dc = [0, 0, -1, 1]

for i in range(4):
    nr = r + dr[i]
    nc = c + dc[i]
# 이런 식으로 인덱스에 직접 더하고 뺄 것을 미리 정해놓고 시작하는 것
# 다만 파이썬에서는 음수인덱스를 지원하니까 에러가 없지만, 다른 언어에서는 에러가 날 수도 있다.
# 다른 언어에서 쓰려면 if문 등을 이용해 에러가 날 경우를 미리 방지해야한다.
```

- 전치 행렬(transpose)
  - n by n행렬일때 대각선을 기준으로 대칭적으로 요소를 바꾼 행렬

#### 부분 집합

- for문을 여러번 중첩하여 사용하는 방법
- 비트연산자를 사용하여 만드는 방법
  - 결국 부분 집합을 구할때 원소가 들어가냐 아니냐로 정하기 때문에 이를 0과 1로 치환하면 2진수로 이를 표현할 수 있다.

  - 그래서 이 부분에 비트 연산자와 관련된 내용을 넣어놓는다.

    - `&` : 비트 단위 and(i&(1<<j): i를 비트로 바꾼 것과 j번째에만 1이 있는 비트와의 비트단위의 and연산을 진행, i의 j번째 비트가 1인지 아닌지를 1과 0으로 리턴)
- `|` : 비트 단위 or
- `<<` : 비트 열을 왼쪽으로 이동( 1<<n: 1을 n만큼 비트단위 왼쪽으로 이동, 나타내는 값은 결국 2^n)
- `>>` : 비트 열은 오른쪽으로 이동

```python
for i in range(1<<len(arr)):
    for j in range(len(arr)):
        if i & (1<<j):
            #부분집합마다 할 내용
```

