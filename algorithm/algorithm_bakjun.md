# 시간 초과

- 공통

- python
  -  여러가지 편의를 위해 다채로운 연산이 가능하지만, 그 연산들이 순식간에 이루어지는 것은 아니다.
  - 대부분의 연산들이 파이썬의 기능이 없다고 생각했을 때 이를 구현했을 때와 같은 정도의 시간이 걸리게 된다.
  - 이런 시간 복잡도를 제대로 알아야만 파이썬으로 시간 초과를 내지 않으면서 코드를 짤 수 있다.
  - (len(a)= O(1)이 의외다.)
- c++
  -  축약 연산과 아닌 것의 시간복잡도가 다르다
  - endl은 느리기 때문에 \n를 사용하는 편이 좋다.
- java
  -  문자열을 더할 때 O(n+k)가 걸리기 때문에 StringBuilder를 사용해야한다.
  - sort가 퀵 소트이기 때문에 정렬하기 전 한번 셔플해주는게 좋다.

# runtime error

- 공통
  - 리스트를 만들 때 필요한 만큼 만드는 경우 인덱스 에러가 나는 경우가 많다.
  - 이를 해결하기 위해 리스트를 좀 더 크게 만들어놓거나, 예외 처리를 해야한다.
  - 경계값을 항상 넣어봐라
  - 전제가 거짓이면 그 명제는 항상 참이다.
  - 가장 큰 값과 가장 작은 값을 항상 확인해보자
  - 컴파일러의 워닝을 항상 주의깊게 봐라

- python
  - 리스트로 만든 리스트에 max를 쓰면 사전순으로 가장 뒤의 list를 찾게 됨으로 사용자가 원하는 이중 리스트의 최댓값과는 다른 결과가 나온다.
  - is  와 == 은 내부 작동 원리가 다르다. 고로 혼용해선 안 된다.
- c++
  - 변수의 저장에 까다롭기 떄문에 항상 초기화에 주의해야한다.
  - printf로 NULL값을 출력하면 틀릴 수 있다.
  - return값이 있는 지 확인
- java
  - 자료형에 담을 수 있는 정수인지 확인

## overflow

- 타입을 신경써서 해야하는 언어일 경우 연산에 의해서 그 범위를 벗어나는지 아닌지를 잘 생각해줘야한다.

## dp 

- 공통
  - 마지막의 한 스텝이 이전과 비교해 어떻게 진행되는 지를 살핀다.
  - memoization을 이용해 될 수 있는 한 빠른 속도로 풀게 만든다.
  - memoization을 할 때 한 연산을 다시 하지 않도록 저장을 해야한다.
  - 연속합과 같은 경우에는 앞에서 뒤로 나아가면서 최대치를 찾아가게 만드는 dp문제와 같다.

## copy

- python
  - 얕은 복사가 기본값
- java
  - 얕은 복사가 기본값
- c++
  - 깊은 복사가 기본값

## 공통

- 실수 되도록 쓰지 마라
- 테스트 케이스를 반대로 쓰는 것도 때로는 좋은 테스트케이스를 발견하는 방법일 수 있다.
- 인덱스에 넣기 전에 범위 검사부터 해라
- 변수명이나 인덱스 순서 등 일관성을 가지고 작성해라.

