# algorithm

## 배열(array)

일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조

- 필요성
  - 여러 개의 변수에 접근할 때마다 새 이름을 짓는 것이 비효율적이기 떄문
- 선언
  - 변수의 처음 할당할 때 생성 혹은 미리 생성
- 접근
  - 인덱스로 접근

## 정렬(sort)

2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값 혹은 그 반대의 순서로 재배열하는 것

이를 정하는 것을 키라고 부른다.

- bubble
  - 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동
  - 한 단계가 끝나면 마지막 원소만 정렬됨
  - 한개씩 물 위로 거품이 올라오는 정렬이라고 하여 bubble이라고 이름 붙음
  - 복잡도 n^2
  - 코딩이 쉽다는 장점이 있다.

```python
def bubble_sort(a):
    for i in range(len(a)-1,0,-1):
        for j in range(0,i):
            if a[j]>a[j+1]:
                a[j],a[j+1] = a[j+1],a[j]
```



- counting

  - 정수나 정수로 표현가능한 자료에만 적용가능하며 미리 할당을 해야하는 경우 최대 정수를 알아야 할당해놓을 수 있다.
  - 집합에 항목들이 몇 개씩 있는 작업후에 한번에 정렬하여 효율적인 알고리즘이다.
  - 복잡도 n+k(n: 리스트 길이, k: 정수 최대값)
  - 동일한 값이 있을 때 그 순서를 유지하는 안정정렬로 쓰기 위해서 순서를 뒤부터 배치한다.
  - n이 커지면 메모리할당측면에서 곤란해져서 비교적 작을 때 의미가 있다.
  - 코드를 읽어보면 알겠지만, 인덱스와 내용물을 뒤바꿔가면서 쓰고 있기 때문에 정수처럼 인덱싱과 겹쳐져도 문제가 없는 경우에만 쓸 수 있다.

  ```python
  def counting_sort(a, k):
      b = [0]*(len(a))
      c = [0]*(k+1)
      for i in range(0,len(b)):
          c[a[i]] += 1
      for i in range(1, len(c)):
          c[i] += c[i-1]
      for i in range(len(b)-1, -1, -1):
          b[c[a[i]]-1] = a[i]
          c[a[i]] -= 1
      return b
  ```

  

- selection
- quick
- insetion
- merge

## 완전검색

문제의 해법으로 생각할 수 있는 모든 경우릐 수를 나열해보고 확인하는 기법

brute-force or genetate and test 기법이라고 불린다.

일반적으로 경우의 수가 적은 경우에만 효율적이다.

죄다 하기 때문에 방식이 정확하다면 답은 어지간하면 찾을 수 있다. 다만 느리기 때문에 방식을 찾아낸 후 이에 효율적으로 적용할 수 있는 알고리즘을 추가로 찾아 적용하는 것이 바람직하다.

### 순열

생성이 가면갈수록 많은 연산을 요구하기 때문에 재귀로 짜는 편이다.



## 탐욕 알고리즘(greedy algorithm)

최적해를 구하는데 사용되는 근시안적 방법

여러 갈래 길 중 그 순간에 최적이라고 생각하는 것을 선택해 진행

지역적으로는 최선을 거듭했지만, 그렇다고 최종결과가 최적이라는 보장은 없다.

일반적으로 생각나는대로 접근하면 greedy 접근이라고 한다.

1. 현재 상태의 부분 문제의 최적 해를 구함, 이를 부분해 집합에 추가
2. 부분해 집합이 실행가능한지, 조건에 맞는 지 검사
3. 부분해 집합이 해가 되는지 검사



### 부분합

- 반복문 두개로 모든 요소를 훑어가면서 계산을 해도 괜찮음
- 하지만 부분합 자체만을 구할 거라면 인덱스를 중복해서 돌리는 곳이 많음
- 이를 줄이기 위해 쓰는 기법 중 슬라이딩 기법이 있다.
  - 그래서 처음에만 부분합을 계산하고 그 뒤부터는 부분합의 첫번째 요소를 빼고 마지막 요소를 더해 다음 부분합을 구함
  - 이렇게 하면 연산량을 줄일 수 있음