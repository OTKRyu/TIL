# algorithm

## stack

- 물건 쌓듯이 자료를 쌓은 자료구조
- 선형 구조
- 자료 삽입 및 자료 출력이 가능하다.
- LIFO(last in first out)

### stack을 구현하기 위한 자료구조와 연산

- 자료구조 : 자료를 선형으로 저장할 수 있는 저장소
  - 저장소 자체를 스택으라고 부리기도 함
  - 마지막 삽입된 원소의 위치를 top이라고 함
- 연산
  - 삽입 : 저장소에 자료를 저장(push)
  - 삭제 : 저장소에서 자료를 삽입순서의 역순으로 삭제하며 반환한다.(pop)
    - 없을 경우도 있기 때문에 이를 잘 생각해서 짜야한다.
  - 스택이 공백인지 아닌지를 확인하는 연산 : isEmpty
  - 스택의 top에 있는 원소를 반환만하는 연산 : peek
    - 없을 경우도 있기 때문에 이를 잘 생각해서 짜야한다.

#### 구현 시 고려 사항

- 1차원 배열을 사용하면 구현이 용이하지만 크기를 변경하기 어렵다는 단점이 있다.
- 동적 연결을 이용하여 이를 해결할 수 있다.

### 사용처
- 재귀호출

자기 자신을 호출하여 순환 수행되는 것

상황에 따라 일반 호출방식보다 간단하게 작성할 수 있다.

이 때 같은 값을 구하기 위해 여러번 호출을 해야하는 비효율성 때문에 memoization이 나왔다.

단순히 재귀로 인해 호출이 많이 되는 값들을 미리 저장을 해놓고 그때그때  뽑아서 쓰는 것이다.

memoization은 dp(dynamic programming)의 핵심이 되는 기술이다.

memorization과 비슷하게 생겼으나 구분해야한다.


- 괄호 검사
- function call
- 계산기
  1. 중위표기법을 후위표기법으로 변경(연산기호를 중간에 놓는것을 뒤에 놓는것으로 바꿈)
  2. 수식을 스택을 통하여 계산

## queue

- 선입선출구조
- 맨 첫번째 원소가 저장된 위치를 `front`, 마지막 원소가 저장된 위치를 `rear`
- 주요연산
  - `enQueue(item)` : rear다음에 원소를 삽입
  - `deQueueu()` : front에서 원소를 삭제하고 반환하는 연산
  - `createQueue()` : 공백 상태의 큐를 생성하는 연산
  - `isEmpty()` : 큐가 공백상태인지 확인
  - `isFull()` : 큐가 포화상태인지 확인
  - `Qpeek()` : front의 위치하는 원소가 뭔지 확인하는 연산
- 선형큐
  - 1차원 배열을 이용한 큐
    - 큐의 크기  배열의 크기
    - `front` : 마지막에 꺼내질 원소의 인덱스
    - `rear` : 저장된 마지막 원소의 인덱스
  - 상태 표현
    - 초기 :  `front` = `rear` = -1
    - 공백 상태 :  `front` = `rear`
    - 포화 상태 :  `rear` = n-1(n:배열의 크기, n-1:배열의 마지막 인덱스)
  - 이용시의 문제점
    - 잘못된 포화상태 인식 : 실제 배열에는 빈 공간이 있으나 front와 rear가 모두 포화상태까지 진행되어버릴경우가 있다.
      - 해결방법1 : 매 원소가 꺼내질 때마다 모든 원소를 한칸씩 앞으로 이동시켜 front값이 항상 같은 값이 되도록 유지, 다만 이 경우 queue의 효율이 급격히 떨어진다
      - 해결방법2 : 원형으로 시작과 끝이 이어진 큐를 만든다.
- 원형큐
  - 초기 공백 상태 : `front` = `rear` = 0
  - index의 순환을 위해 mod를 이용.
  - 공백상태와 포화상태의 구분을 쉽게 하기 위해 `frnot`는 항상 비워둠(원형큐의 경우 포화상태일때도 front와 rear가 같아질 수 있기 때문)
  - 선형큐와 구동 과정이 거의 같지만 mod를 통해 순환한다는 것과 포화상태에 대한 판단방법정도만 다르다.
  - 포화상태일때는 `rear` + 1 = `front`일 때이다.
- 연결 큐 : 단순 연결 리스트를 이용한 큐
  -  큐의 원소: 단순 연결 리스트의 노드
  -  원소 순서: 노드의 연결 순서
  -  `front` : 첫 번째 노드를 가르키는 링크
  -  `rear` : 마지막 노드를 가르키는 링크
  -  초기 및 공백 상태 : `front` = `rear` = `None`

### Queue의 활용

- 버퍼
  - 데이터를 이동시키는 동안 잠시 데이터를 보관하는 메모리의 영역
  - 입출력 및 네트워크와 관련 기능에서 이용 순서대로 이루어져야하므로 큐가 사용된다.

## 우선순위 큐(Priority Queue)

우선순위를 가진 항목들을 저장하는 큐

선입선출이 아닌 우선순위대로 나가게 된다.

- 배열을 이용하여 우선순위 큐 구현
  - 삽입시 우선순위를 비교하여 적절한 위치에 삽입
  - 최고 우선순의 원소가 가장 앞에 위치
  - 문제점 : 배열을 사용하므로 삽입이나 삭제 연산이 일어날 때 원소의 재배치 발생, 이로 인하여 시간과 메모리 낭비가 큼, 이를 해결하기 위해 힙이나, 연결 리스트등을 이용하게 됨.

