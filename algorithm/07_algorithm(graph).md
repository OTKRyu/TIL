# algorithm

## graph

- 아이템과 이들 사이의 연결 관계를 표현한다
- 정점의 집합(v)과 이들을 연결하는 간선의 집합(e)으로 구성된 자료이다.
- 선형 혹은 트리로 표현하기 어려운 m:n관계를 표현할 때 용이하다.

### 유형

- 무향(undirected)
- 유향(directed)
- 가중치(weighted)
- 사이클이 없는 방향 그래프(directed acyclic)
- 완전 그래프(모든 정점이 서로 연결되어 있는 그래프)
- 불완전 그래프

### 용어

- 인접(adjacency)
  - 두 개의 정점 사이의 연결된 간선이 있으면 인접해 있다고 한다.
  - 완전 그래프는 임의의 두 정점들이 모두 연결되어 있다.
- 그래프 경로
  - 간선들을 순서대로 나열한 것
  - 한 정점을 한번만 지나는 경로 단순 경로
  - 한 바퀴 돌아서 출발점에서 끝나는 경로를 회로(cycle)

### 표현

간선의 정보를 저장하는 방식, 메모리나 성능을 고려해서 결정

- 인접 행렬(adjacent matrix)
  - 2차원 배열을 이용해서 간선 정보 저장
  - 유향일 경우 대체로 행을 진출, 열을 진입으로 생각한다. 그래서 행의 합을 진출차수, 열의 합을 진입차수라고 부른다.
- 인접 리스트(adjacent list)
  - 각 정점마다 해당 정점으로 나가는 간선의 정보를 저장
- 간선의 배열
  - 간선의 시작점과 끝점을 모두 저장

### 그래프의 순회

- 그래프의 모든 정점을 방문하는 방법
- DFS와 BFS 이렇게 두 가지 방법이 있다.
- DFS
  - 시작 정점에서 한 방향으로 갈 수 있는데까지 갔다고 더 이상 갈 곳이 없으면 마지막 갈림길로 돌아와 다음 방향을 탐색하는 방법
  - 이를 위해서 스택을 사용

### 서로소 집합(상호배타 집합)(disjoint set)

상호 공유하는 정점이 없는 집합을 서로소 집합이라고 부른다.

- 표현 방법
  - 연결 리스트
  - 트리
    - 자식 노드가 부모 노드를 가르키도록 하여 루트 노드를 그 집합의 대표 원소로 만든다.
    - 부모가 없는 경우 = 루트 노드 인 경우 자기 자신을 가르키게 만든다. 이를 통해 어느게 루트 노드인지를 확인할 수 있다.
  
- 용어

  - make-set(ele) : ele 원소를 지닌 집합을 하나 만든다

  ```python
  def make_set(x):
      p[x] = x
  ```

  - find-set(ele) : ele이 속한 집합의 대푯값을 찾아온다.

  ```python
  def find_set(x):
      if x==p[x]:
          return x
      else:
          return find_set(p[x])
      
  def find_set2(x):
      while x!=p[x]:
          x = p[x]
      return x
  ```

  - union(a,b) : a가 속한 집합과 b가 속한 집합을 합집합한다. 

  ```python
  def union(a,b):
      p[find_set(b)]=find_set(a)
  ```

- 연산의 효율을 높이는 방법

  - rank를 이용한 union

    - 각 노드는 자신을 루트로 하는 subtree의 높이를 랭크라는 이름으로 저장
    - 두 집합을 합칠 때 rank가 낮은 집합을 rank가 높은 집합에 붙임
    - 이렇게 하면 union을 해도 rank가 높아지지 않으며 최대랭크시간만에 탐색을 마치게 만들어줄 수 있다.
    - 동일한 경우에는 별 수 없이 rank가 하나 높아질 수 밖에 없다.

    ```python
    def union(x,y):
        link(find_set(x),find_set(y))
        
    def link(x,y):
        if rank[x] > rank[y]:
            p[y] = x
        else:
            p[x] = y
            if rank[x] == rank[y]:
                rank[y] += 1
    ```

  - path compression

    - find-set을 행하는 과정에서 만나는 모든 노드들이 직접 root를 가리키도록 포인터를 바꾸어준다.

    ```python
    def find_set_with_path_compression(x):
        if x!= p[x]:
            p[x] = find_set_with_path_compression(p[x])
        return p[x]
    ```

### tree

#### 주의점

- 부모가 꼭 자식보다 낮은 값으로 지정되지 않을수도 있다.
- 루트가 꼭 1이란 보장은 없다.
- 포화 이진 트리의 형식을 맞춰서 번호를 줄거란 보장도 없다.

#### 특징

- 비선형 구조
  - 원소들 간의 1:n 관계를 가지는 자료구조
  - 원소들 간에 계층관계를 가지는 계층형 자료구조
- 원소들 간에 1:n 관계
- 원소들 간의 계층관계, 계층형 자료구조
- 상위에서 하위로 확장되는 트리모양 구조
- 두 노드 사이에는 유일한 경로가 존재
- 각 노드는 최대 하나의 부모 노드가 존재할 수 있음
- 각 노드는 없거나 하나 이상의 자식 노드가 존재할 수 있다.

#### 정의

- 한 개 이상의 노드로 이루어진 유한 집합
  - 최상위 노드(부모가 없는 노드) = 루트
  - 나머지 노드들을 분리 가능, 이 분리된 집합들도 트리가 되고 이를 부트리 혹은 서브트리라고 한다.
  - 더이상의 부 트리를 가지지 않는(혹은 자식이 없는) 노드를 단말 노드, 터미널 노드, leaf node라고 부른다.

#### 용어

- 노드(node) : 트리의 원소
- 간선(edge) : 노드를 연결하는 선
- 루트 노드(root node) : 트리의 시작 노드
- 형제 노드(sibling node) : 같은 부모 노드를 공유한 자식 노드들
- 조상 노드: 간선을 따라 루트 노드까지 이르는 경로에 있는 모든 노드
- 서브트리(subtree) : 부모 노드와 연결된 간선을 끊었을 때 생성되는 트리
- 자손 노드: 서브 트리에 있는 하위레벨의 노드들
- 차수
  - 노드의 차수: 노드에 연결된 자식 노드의 수
  - 트리의 차수: 트리에 있는 노드의 차수 중 가장 큰 값
- 높이
  - 노드의 높이: 루트에서 노드에 이르는 간선의 수 노드의 레벨
  - 트리의 높이: 노드의 높이 중 최대값

#### 이진트리(binary tree)

- 모든 노드들이 2개의 서브트리를 갖는 특별한 형태의 트리
- 각 노드가 자식 노드를 최대 2개만 가질 수 있는 트리

##### 특성

- 레벨 i에서의 노드의 최대 개수는 2^i개
- 높이가 h인 이진 트리가 가질 수 있는 노드의 최소 갯수는 h+1개가 되며, 최대 갯수는 2^(h+1)-1개가 된다.

##### 종류

- 포화 이진 트리(full binary tree)
  - 모든 레벨의 노드가 다 차 있는 이진 트리
  - 구조가 정해진 것과 같으므로 정해진 위치에 노드 번호를 붙일 수 있음
  - 루트부터 시작해 레벨을 내려가면서 왼쪽에서 오른쪽으로 번호를 붙인다.
- 완전 이진 트리(complete binary tree)
  - 높이가 h이고 노드 수가 n개일 때 포화 이진 트리의 노드 번호 기준 빈 자리 없이 잘 채운 트리.
- 편향 이진 트리(skewed binary tree)
  - 높이 h에 대한 최소 개수의 노드를 가진 이진 트리면서 한쪽 방향으로만 진행된 이진트리
- 수식 트리(expression binary tree)
  - 수식을 표현하는 이진 트리
  - 연산자는 루트 노드이거나 가지 노드
  - 피연산자는 모두 잎 노드
- 이진 탐색 트리
  - 탐색작업을 효율적으로 하기 위한 자료구조
  - 모든 원소는 서로 다른 유일한 키를 갖는다.
  - key(왼쪽 서브트리) < key(루트 노드) < key(오른쪽 서브트리)
  - 부 트리들도 이진 탐색 트리다
  - 중위 순회하면 오름차순으로 정렬된 값을 얻을 수 있다.
  - 연산
    - 결국 이 아래의 연산들은 트리의 깊이만큼 시간이 걸리게 된다.
    - 탐색
      - 루트에서 시작
      - 탐색할 키값과 현재 노드의 키 값을 비교(같으면 성공, 작으면 왼쪽 서브트리, 크면 오른쪽 서브트리)
      - 찾을 때 까지 위 작업을 반복
      - 평균적인 경우 logn정도면 찾지만, 최악의 경우 n정도의 시간으로 선형과 같아질 수 있다.
    - 삽입
      - 탐색을 하다가 실패한 위치를 기준으로 작으면 왼쪽으로, 크면 오른쪽으로 자식노드로 삽입하게 되면 규칙을 지키면서 삽입할 수 있다.
    - 삭제
      - 탐색을 해서 찾은 다음 leaf일경우는 간단히 삭제할 수 있다.
      - 다만 문제는 leaf가 아닐 경우인데 자식이 하나일 경우까지는 연결만 바꿔주면 되겠지만, 자식이 두 개일 때부터는 일이 복잡해진다.
      - 이렇게 할 경우 삭제 대상의 자리를 대체할 수 있는 대상을 탐색해서 고정하고, 이 대상으로 대체했을 때에도 이진 탐색 트리의 구조가 무너지지 않게 만들 수 있게 만들어야되는데 이게 쉽지가 않다. 이를 하기 위해서 대체 대상의 서브 트리를 통째로 끌고와서 새롭게 연결을 하는 등에 노력이 필요하다.

#### 최소 신장 트리(MST)

- 그래프에서 최소 비용 문제 
  - 모든 정점을 연결하는 간선들의 가중치의 합이 최소가 되는 트리
  - 두 정점 사이의 최소 비용의 경로 찾기
- 신장 트리
  - n개의 정점으로 이루어진 무방향 그래프에서 n개의 정점과 n-1개의 간선으로 이루어진 트리
- 최소 신장 트리(minimum spanning tree)
  - 무방향 가중치 그래프에서 신장 트리를 구성하는 간선들의 가중치의 합이 최소인 신장트리

##### kruskal algorithm

간선을 하나씩 선택해서 MST를 찾는 알고리즘

1. 최초, 모든 간선을 가중치에 따라 오름차순으로 정렬
2. 가중치가 가장 낮은 간선부터 선택하면서 트리를 증가
   - 사이클이 존재하면 다음으로 가중치가 낮은 간선 선택
   - 이 때 사이클인지 아닌지를 판단하는데 disjoint set를 사용한다.
   - 만약 이전에 연결된 적이 있었다면 집합에 소속되어 있을 것인데 이 순서대로라면 같은 집합끼리는 이미 한번씩은 연결되어 있다. 이 상태에서 집합 내의 점과 다시 연결하려 든다면 모두 연결된 상태에서 다른 경로를 잇는 꼴이 되기때문에 회로가 된다.
   - 이런 경우는 피하고 다음 최소 간선으로 시도한다.
   - 즉 같은 집합에 소속되어 있는지 아닌지를 통해 있다면 회로로, 아니라면 회로가 아닌 걸로 판단한다.
3. n-1개의 간선이 선택될 때까지 2를 반복

```python
def kruskal(tree, n): # tree는 가중치 순으로 정렬이 되어있다고 가정하자, 최소신장 트리의 총 길이를 구하는 알고리즘
    cnt = 0
    idx = 0
    result = 0
    while cnt < n:
        c = tree[idx] # c는 [정점, 정점, 가중치]로 되어있다.
        if find(c[0]) == find(c[1]):
            idx += 1
        else:
            result += c[2]
            union(c[0], c[1])
            idx += 1
            cnt += 1
    return result

def union(x, y):
    disjoints[find(y)] = find(x)


def find(x):
    if x == disjoints[x]:
        return x
    else:
        return find(disjoints[x])
```



##### prim algorithm

1. 임의의 정점 하나 선택해서 MST에 추가
   - 어차피 모든 점을 연결해야하기 때문에 초기 정점을 어떤 정점으로 잡아도 상관이 없다.
2. MST에 속한 정점들과 인접하는 정점들 중의 최소 비용의 간선이 존재하는 정점을 선택
3. 모든 정점이 MST에 포함될 때까지 과정을 반복

포함 되었는지를 확인하기 위한 MST, 인접한 정점들 중 어느게 가장 비용이 작은지를 확인하기 위한 key  array가 필요하다.

#### 순회(traversal)

트리의 각 노드를 "체계적으로"중복되지 않게 전부 방문하는 것을 말함, 다만 비 선형 구조이기 때문에 선형구조에서와 같이 선후 연결 관계를 알 수는 없다.

순회의 목적이 때에 따라 다른 편이므로 목적에 맞는 순회를 생각해 시도하는 것이 좋다.

- 전위 순회(preorder) : vlr

  - 부모노드 방문 후, 자식노드를 좌우 순으로 방문

  - ```python
    def preorder_traverse(T):
        if T:
            visit(T)
            preorder_traverse(T.left)
            preorder_traverse(T.right)
    ```

- 중위 순회(inorder) : lvr

  - 왼쪽 자식노드, 부모노드, 오른쪽 자식노드 순으로 방문

  - ```python
    def inorder_traverse(T):
        if T:
            preorder_traverse(T.left)
            visit(T)
            preorder_traverse(T.right)
    ```

- 후위 순회(postorder) : lrv

  - 자식노드를 좌우 순서로 방문 후, 부모노드 방문

  - ```python
    def postorder_traverse(T):
        if T:
            preorder_traverse(T.left)
            preorder_traverse(T.right)
            visit(T)
    ```

#### 표현

아래와 같은 방식으로 표현하려고 하지만, 모든 문제에서 친절하게 아래와 같은 규칙대로 주는 것은 아니다. 그렇기 때문에 각자 상황에 맞게 변형해 다룰 수 있는 능력을 갖춰야한다.

```python
'''
이진트리의 연결관계는 많아봐야 2이므로 부모의 위치를 인덱스로 하는 리스트 두 개를 활용하여 만들 수 있다.
부모 노드를 이용해 자식의 번호를 저장한 경우
'''
if ch1[p]==0:
    ch1[p] = c
else:
    ch2[p] = c
    
# 자식의 노드를 이용해 부모의 번호를 저장할 수도 있다. 이 때 부모가 없어서 초깃값 그대로 남아있는 노드가 root가 된다.
```

- 배열을 이용한 이진 트리의 표현
  - 이진 트리에 각 노드 번호를 부여
  - 루트의 번호가 1
  - 레벨 n에 있는 노드에 대하여 2^n부터 시작해 왼쪽부터 오른쪽으로 번호를 차례대로 부여
  - 성질
    - 노드 번호가 i인 노드의 부모 노드 번호 : i//2
    - 노드 번호가 i인 노드의 왼쪽 자식의 노드 번호 : 2*i
    - 노드 번호가 i인 노드의 오른쪽 자식의 노드 번호 : 2*i+1
    - 레벨 n의 노드 번호 시작 번호 : 2^n
  - 단점 : 빈곳이 많을 경우 메모리 공간 낭비가 발생하고, 트리의 중간에 새로운 노드를 삽입하거나 기존의 노드를 삭제할 경우 배열의 크기 변경이 어려워 비효율적이다.
- 연결 리스트를 이용한 이진 트리의 표현
  - 리스트보다 노드의 삽입과 제거가 쉽다는 이점이 있음
  - 연결 리스트를 이용할 때 부모에게서 자식에게로만 링크를 걸어놓는 single linked list와 부모와 자식 서로가 서로에게 링크를 걸고 있는 double linked list 두 가지가 있다. 이 방법에 따라서 코드가 달라져야한다.
  - 자세한 구현은 다루지 않는다.

#### heap

완전 이진 트리에 있는 노드 중 키값이 가장 큰 노드나 키값이 가장 작은 노드를 찾기 위해서 만든 자료구조

이를 활용하여 우선순위 큐를 구현할 수 있다.

파이썬의 경우 라이브러리로 구현되어 있기 때문에 필요한 경우 heapq로 쓸 수 있다.

- 최대 힙

  - 최대값을 찾기 위한 완전 이진 트리
  - 부모의 키값이 항상 자식의 키값보다 크다
  - 루트 노드는 키값이 가장 큰 노드

- 최소 힙

  - 최소값을 찾기 위한 완전 이진 트리
  - 부모의 키값이 항상 자식의 키값보다 작다
  - 루트 노드는 키값이 가장 작은 노드

- 연산

  - 삽입
    - 완전 이진 트리여야하기 때문에 추가될 자리는 고정되어 있다.
    - 그 후 부모 자식간의 대소관계를 비교하여 교환하는 행위를 힙이 될 때까지 반복한다.
  - 삭제(pop)
    - 루트 노드의 원소만을 삭제한다.
    - 그러면 루트 노드가 비는데 그러면 완전이진트리이기 때문에 마지막 원소를 가지고 오고 그 자리를 지운다.
    - 이 원소가 최대인지를 자식들과 비교하여 자식 중 큰 쪽과의 교환을 힙이 될 때까지 계속한다.

- 힙의 활용

  - 특별한 큐의 구현과 정렬

  - 힙이 우선순위 큐를 구현하는 가장 효율적인 방법

    - 노드 하나의 추가 및 샂게의 시간 복잡도가 logn이고 최대값을 한번의 접근으로 바로 얻어올 수 있다.
    - 완전 정렬보다 관리 비용도 적은 편이다.

  - 배열을 통해 쉽게 구현할 수 있다.

    