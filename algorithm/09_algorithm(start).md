# algorithm

## SW 문제 해결

여러가지 요소를 적재적소에 배치해 큰 그림을 그릴 수 있는 능력이라고 말할 수 있지만, 추상적이기도 하고 마냥 늘리기 쉬운 것도 아니다.

이를 기르기 위해 인위적인 상황을 만들어 훈련하는 것이 효율적이다. 

### 해결 과정

1. 문제를 읽고 이해
2. 문제를 재정의
3. 계획을 세움
4. 계획을 검증
5. 실제로 구현
6. 반성 및 개선 방안 모색

### 전략

- 직관 및 체계적인 접근

## 복잡도 분석

- 알고리즘: 어떤 문제를 해결하기 위한 절차나 방법
- 알고리즘의 효율
  - 공간적 효율성: 메모리를 얼마나 쓰느냐
  - 시간적 효율성: 시간을 얼마나 줄일 수 있는가
    - 하드웨어 환경에 따라 변화
    - 소프트웨어 환경에 따라서도 변화
    - 고로 분석이 쉽지 않다.
    - 그래서 입력 크기에 대한 함수로 주로 표기하게 된다. 대표적인 표기법으로는 아래와 같은 종류들이 있다.
      - big oh
        - 점근적 상한을 의미, n이 커질 수록 최고차항이 값을 지배하게 되므로 최고차항만 쓰는 편이다.
      - big omega
        - 점근적 하한을 의미, n이 커졌을 때 최소한 이것만큼은 걸린다라고 표기하는 것이다.
      - big theta
        - big oh 와 big omega가 같은 경우 쓰는 표기법으로, n이 증가함에 따라 연산량의 증가율이 theta와 같다는 의미를 지닌다.
  - 복잡도와 완전히 반대의 개념으로 반비례한다.

- 왜 효율적인 알고리즘이 필요한가
  - 결국 주어진 시간과 공간이 한정적이기 때문
  - 이 시간과 공간을 하드웨어를 개발함으로서 늘릴 수 있지만, 하드웨어의 개발보다 훨씬 적은 자원으로도 알고리즘을 개선함으로서 효율을 높일 수 있음

## python 표준 입출력

- 입력
  - input : 표준 입력, 받은 것을 문자열로 취급
  - eval(input()) : 받은 입력값을 명령어로 인식, 실제로 실행이 되어버리기 때문에 위험하다.
- 출력
  - print : 표준 출력, 개행 문자 포함
  - print('%d' %number) : formatting 한 출력
- 파일 내용
  - sys.stdin = open("a.txt","r")
    - 파이참의 경우 표준입력이 1mb라서 이걸 넘어가면 제대로 인지를 못한다. 이럴 경우 그냥 파일 자체를 열어서 가져와야하는데 이럴 경우 쓰게 된다. 
  - sys.stdout = open("output.txt", "w")

## 비트 연산
### 정수


- MSB, LSB : most significant bit, lest significant bit 로 비트 중에 가장 큰 값을 담당하고 있는 자리와 가장 작은 값을 담당하고 있는 자리를 말한다.

- `&`: 비트 단위의 and연산
- `|` : 비트 단위의 or연산
- `^` : 비트 단위의 xor연산, 비트를 반전시킬 떄도 쓸 수 있다.
- `~` : 모든 비트를 반전, 다만 int의 경우 이렇게 하면 보수법 떄문에 내가 원하는 수가 나오지 않을 수 있으니 이점 유의
- `<<` : 비트열을 왼쪽으로 이동, 즉 2배 
- `>>` : 비트열을 오른쪽으로 이동, 즉 1/2배
- 비트를 통해 음수를 표현하는 방법
  - 부호 크기 표현 : 맨 앞자리 수를 부호를 나타내는 방법. 간단하지만, 연산에서 제대로 된 값을 뽑아내려면 추가 연산이 필요하기 때문에 쓰기 어렵다.
  - 1의 보수 표현 : 비트로 나타낸 수를 0과 1을 반전시킨 값을 음수로 표현
  - 2의 보수 표현 : 1의 보수로 만든 후 1을 더하는 것으로 음수를 표현한 것
    - 양수 음수 구분 확실
    - 음수를 더하는 단순한 방식으로 셈 수행 가능
    - 음수끼리의 비교연산에서 생기는 모순 해결
    - 0의 표현 방식 하나로 고정 가능
- 엔디안(endianness)
  - 컴퓨터의 메모리와 같은 1차원의 공간에 여러 개의 연속된 대상을 배열하는 방법을 의미하며 hw architecture마다 다르다.
  - 속도 향상을 위해 바이트 단위와 워드 단위를 변환하여 연산 할 때 올바로 이해하지 않으면 오류를 발생 시킬 수 있다.
  - 이 엔디안 때문에 16진수를 2진수로 바꾸거나 할 때 저장순서가 다르기 때문에 출력순서가 달라지거나하는 경우가 생길 수 있다.
  - 빅 엔디안
    - 보통 큰 단위가 앞에 나옴, 네트워크가 대표적이다.
  - 리틀 엔디안
    - 작은 단위가 앞에 나옴, 대다수 데스크탑 컴퓨터가 이 방법을 따르고 있다.
- 진수 변환
  - 2~4~8~16 끼리의 변환과 10진수로의 변환도 있다마는 기본적으로 원리는 별거 없다.

### 실수

컴퓨터는 실수를 근사적으로 표현하기 때문에 항상 정확한 결과를 기대해서는 안 되고 근삿값 정도를 기대해야 한다.

고로 유효 자릿수를 알아 둬야 한다.

32 비트 실수형의 경우 유효자릿수는 6자리이고, 64비트 실수형의 경우 유효자릿수는 15자리정도이다.

- 실수의 변환
  - 각 자리에 해당하는 실수들을 더해서 만든다.
- 실수의 표현
  - 부동소수점 표기법을 사용
  - 소수점의 위치를 고정시키고 밑수의 지수승으로 표현
  - 가수부분으로 값이 어떤지를 저장해놓기 때문에 숫자의 크기가 지수단위로 차이가 나게 되면, 같은 길이의 가수부를 가지고 있다고 한들 소수부분의 자릿수가 같기를 기대할 수 없다.
  - 파이썬에서는 더 많은 비트를 이용해서 넓은 범위의 실수를 표현할 수 있다. 최대 1.8 * 10 ^308, 이 이상은 inf로 표현. 이 때 inf는 실수표현이므로 정수와 관련된 문제에서는 사용하지 않아야 한다. 최소는 10 ^ -324 정도이다. 이 이하는 사실상 0과 다름이 없다고 표시한다.
- 실수의 저장
  - 단정도 실수
    - 부호 1비트, 지수 8비트, 가수 23비트
    - 실제로 만들 때는 가장 큰 자리의 숫자가 1의 자리에 오도록 지수부를 조정하고, 나머지 가수 부분은 23비트로 만든다.
    - 이 때 지수부에 쓸 수 있는 것은 8비트이지만 음수와 양수 모두 써야하는데 이 때 2의 보수가 아닌 익세스표현법이라는 것을 쓴다.
    - 익세스 표현법은 가장 큰 값을 절반크기까지 만약 8비트라면 128에 할당하고 가장 작은 값을 -127에 할당하는 방법으로, 간단하게 생각하면 음수 중 가장 작은 값을 0으로 할당하고 그로부터 다른 수들을 할당하는 방법이다.
  - 배정도 실수 : 주로 이걸 쓴다.
    - 부호 1비트, 지수 11비트, 가수 52비트