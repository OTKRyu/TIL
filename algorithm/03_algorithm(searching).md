# algorithm

## 검색

- 저장되어 있는 자료 중 원하는 항목을 찾는 작업
- 키를 가지고 검색할 수도 있다.

### 숫자 검색 방법

- 순차 검색(sequential search)

  - 일렬로 되어 있는 자료를 순서대로 검색
  - 구현이 간단한 만큼 검색 대상 수가 많아질수록 급격히 비효율적으로 변함
  - 정렬이 됐을 때와 아닐 때 찾는 방법에 약간의 차이가 있으며, 정렬이 됐을 때 조금 더 효율적으로 사용할 수 있다.

- 이진 검색(binary search)
  - 일단 정렬이 되어있어야만 함.
  - 중앙 원소를 고르고 목표 값과 비교한 후, 목표값이 크면 오른쪽을 작으면 왼쪽을 대상으로 다시 이 과정을 반복한다.
  - 재귀함수를 통해서도 구현할 수 있다.

```python
def binary_serch(a, key):
    start = 0
    end = len(a) - 1
    while start <= end:
        middle = (start + end) // 2
        if a[middle] == key:
            return True
        elif a[middle] < key:
            start = middle + 1
        else:
            end = middle - 1
    return False
```

- 선택 검색(seletion searching)
  - k번째로 작은 수를 구하는 방법
  - 정렬후 k번재 원소를 구한다.

### string searching
- 고지식한 알고리즘(brute force)
  - 처음부터 끝까지 차례대로 순회하면서 일일히 비교
  - 찾고자 하는 부분과 전체가 있을건데 이때 양쪽 인덱스를 함께 돌면서 부분의 첫번째와 전체의 첫번째가 같으면 같이 넘어가되 틀리면 부분은 맨 처음으로 돌아가지만 전체는 순회를 시작한 첫부분보다 한 칸 더 앞으로 가서 탐색을 진행하는 방식이다.
  - 시간복잡도 : 부분의 길이 * 전체의 길이
- kmp 알고리즘
  - 매칭이 실패했을 때 돌아갈 곳을 미리 정해놓고 그 부분에서만 연산을 처리하고 넘어가는 방법이다
  - 돌아갈 곳을 정할 때, 부분의 접두사와 접미사가 일치하는 경우를 찾아 그 때 접두사와 접미사의 길이의 최대치만큼을 뽑아내서 그 자리에 넣어 탐색할 곳을 찾는다. 이렇게 해서 표를 만들어두면 부분과 전체가 일치하지 않는 곳을 찾았을때 전체의 뒤로 돌아가서 찾는것이 아니라 앞부분의 맞는부분까지는 연산하지 않고 뒤의 알수없는 부분만 새로 계산하는 것이다.
  - 시간복잡도 : 부분의 길이 + 전체의 길이
- 보이어-무어 알고리즘
  - 오른쪽에서 왼쪽으로 비교
  - 대부분의 상용 소프트웨어가 채택하고 있다.
  - 불일치시, 불일치한 전체의 원소와 일치하는 부분의 원소가 있는경우 그 둘을 일치시킬때로 이동하여 진행한다. 이 때 일치하는 원소가 여럿이면 만약을 위해 가장 앞의 인덱스에 해당하는 원소와 맞춰 이동
  - 불일치한 전체의 원소와 일치하는 부분의 원소가 없는경우 부분의 길이만큼 이동하여 진행한다.
  - 시간 복잡도는 케이스에 따라 다르지만 평균적으로는 부분의길이 + 전체의 길이만큼 걸리고, 최악의 경우 부분의 길이 * 전체의 길이만큼 걸린다. 
- 카프 라빈 알고리즘
- 비교
  - brute force와 kmp는 전체를 한번씩은 일주하지만, 보이어무어는 그냥 건너뛰는 경우도 있다.
  - 보이어무어는 읽는 순서가 오른쪽부터다.

## 그래프 탐색

### dfs(깊이 우선 탐색)

- 비선형 구조일 때 모든 자료를 다 검색하는 것이 중요하다.
- 이 때 깊이를 우선하면 dfs(depth first search), 너비를 우선하면(breadth first search)라고 한다.
- 시작 정점에서 한 방향으로 갈 수 있는 곳까지 갔다가 더 이상 갈 곳이 없게 되면, 마지막 갈림길로 돌아와 다른 방향으로 탐색을 계속하여 모든 정점을 방문하는 순회방법
- 가장 마지막에 만났던 갈림길의 정점으로 되돌아가야하므로 후입선출 구조의 스택 사용

#### 실제 사용 방법

1. 시작 정점 v를 결정하여 방문
2. v의 인접한 정점 중에
   1. 방문하지 않은 정점 w가 있으면 정점 v를 스택에 push하고 w를 v로 하여 2.반복
   2. 방문하지 않은 정점이 없으면, 탐색의 방향을 바꾸기 위해 스택을 pop하여 받은 가장 마지막 방문 정점을 v로 하여 다시 2)를 반복
3. 스택이 공백이 될 때까지 2반복

```
# psudo code
visited = [], stack = []
dfs(v):
	v 방문;
	visited[v] = True;
	do {
		if (v의 인접 정점 중 방문 안한 w 찾기)
			push(v):
		while (w){
		w 방문;
		visieted[w] = True;
		push(w);
		if 방문하지 않은 w의 접점이 있다면:
			w = 방문하지 않은 현 w의 새로운 접점;
		else:
			stack.pop();
			w = stack.peek();
		if stack.isEmpty == True:
			break
		}
	}
```

```
# psudo code by recursion
dfs_recursive(g, v)
	visited[v] = True
	for each all w in adjacency(g, v)
		if visited[w] != True
			dfs_recursive(g, w)
```

```
# psudo code by repeat
stack s
visited []
dfs(v)
	push(s,v)
	while not isempty(s)
		v = pop(s)
		if not visited[v]
			visit(v)
			for each w in adjacency(v)
				if not visited[w]
					push(s, w)
```

이 때 중요한 것인 현재 위치를 기준으로 어떤게 인접한지를 아는 것인데 이를 처리하는 방법이 인접행렬과 인접리스트이다.

- 인접행렬
  -  정점의 개수가 n일 경우 n by n짜리 행렬에 연결이 되어있다면 1을 아니라면 0을 넣어서 연결관계를 나타내는 것이다.
- 인접리스트
  - 정점의 개수가 n일 경우 n짜리 리스트를 만들어 n번째 점의 경우 n개의 연결관계중 연결이 되어있으면 1을 아니라면 0을 넣어 표현하는 것이다.