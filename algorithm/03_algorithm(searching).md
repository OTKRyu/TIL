# algorithm

## 검색

- 저장되어 있는 자료 중 원하는 항목을 찾는 작업
- 키를 가지고 검색할 수도 있다.

### 숫자 검색 방법

- 순차 검색(sequential search)

  - 일렬로 되어 있는 자료를 순서대로 검색
  - 구현이 간단한 만큼 검색 대상 수가 많아질수록 급격히 비효율적으로 변함
  - 정렬이 됐을 때와 아닐 때 찾는 방법에 약간의 차이가 있으며, 정렬이 됐을 때 조금 더 효율적으로 사용할 수 있다.

- 이진 검색(binary search)
  - 일단 정렬이 되어있어야만 함.
  - 중앙 원소를 고르고 목표 값과 비교한 후, 목표값이 크면 오른쪽을 작으면 왼쪽을 대상으로 다시 이 과정을 반복한다.
  - 재귀함수를 통해서도 구현할 수 있다.

```python
def binary_serch(a, key):
    start = 0
    end = len(a) - 1
    while start <= end:
        middle = (start + end) // 2
        if a[middle] == key:
            return True
        elif a[middle] < key:
            start = middle + 1
        else:
            end = middle - 1
    return False
```

- 선택 검색(seletion searching)
  - k번째로 작은 수를 구하는 방법
  - 정렬후 k번재 원소를 구한다.

### string searching
- 고지식한 알고리즘(brute force)
  - 처음부터 끝까지 차례대로 순회하면서 일일히 비교
  - 찾고자 하는 부분과 전체가 있을건데 이때 양쪽 인덱스를 함께 돌면서 부분의 첫번째와 전체의 첫번째가 같으면 같이 넘어가되 틀리면 부분은 맨 처음으로 돌아가지만 전체는 순회를 시작한 첫부분보다 한 칸 더 앞으로 가서 탐색을 진행하는 방식이다.
  - 시간복잡도 : 부분의 길이 * 전체의 길이
- kmp 알고리즘
  - 매칭이 실패했을 때 돌아갈 곳을 미리 정해놓고 그 부분에서만 연산을 처리하고 넘어가는 방법이다
  - 돌아갈 곳을 정할 때, 접두사와 접미사가 일치하는 경우를 찾아 그 때 접두사와 접미사의 길이의 최대치만큼을 뽑아내서 그 자리에 넣어 탐색할 곳을 찾는다. 이 때 첫 글자는 접두사 접미사가 없기때문에 -1로 처리하고, 접두사와 접미사가 일치하는 경우가 없으면 0을 넣는다.
  - 시간복잡도 : 부분의 길이 + 전체의 길이
- 보이어-무어 알고리즘
  - 오른쪽에서 왼쪽으로 비교
  - 대부분의 상용 소프트웨어가 채택하고 있다.
  - 불일치시, 불일치한 전체의 원소와 일치하는 부분의 원소가 있는경우 그 둘을 일치시킬때로 이동하여 진행한다.
  - 불일치한 전체의 원소와 일치하는 부분의 원소가 없는경우 부분의 길이만큼 이동하여 진행한다.
  - 시간 복잡도는 케이스에 따라 다르지만 평균적으로는 부분의길이 + 전체의 길이만큼 걸리고, 최악의 경우 부분의 길이 * 전체의 길이만큼 걸린다. 
- 카프 라빈 알고리즘
- 비교
  - brute force와 kmp는 전체를 한번씩은 일주하지만, 보이어무어는 그냥 건너뛰는 경우도 있다.
  - 보이어무어는 읽는 순서가 오른쪽부터다.